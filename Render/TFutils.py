import numpy as np
import matplotlib.pyplot as plt
from icecream import ic
import json
#* Note: Paraview TFs json file format:
#* GetOpacityTransferFunction("ImageFile").Points:  get the opacity term of transfer function
#* Points:  a flattened list of (data-value, opacity, mid-point, sharpness), mid-point usually set to 0.5, sharpness usually set to 0.0

#* GetColorTransferFunction("ImageFile").RGBPoints:  get the color term of transfer function
#* RGBPoints: The value is a flattened list of tuples, (data-value, red, green, blue). The color components, must be in the range [0.0, 1.0]

#* these two attributes can also be set manually with an array

def write_palette_txt(palette_rgb, path):
    palette_str = ''
    for i, c in enumerate(palette_rgb):
        palette_str += f'{c[0]} '
        palette_str += f'{c[1]} '
        if i < len(palette_rgb) - 1:
            palette_str += f'{c[2]}\n'
        else:
            palette_str += f'{c[2]}'
    with open(path, 'w') as f:
        f.write(palette_str)
        
def write_TF_json(TF, save_path, TF_name='TF'):
    #* write the TF to a json file that can also be loaded by Paraview
    save_TF_json = [{"ColorSpace": "RGB", "Name": TF_name, "RGBPoints": None, "Points": None}]
    save_TF_json[0]['RGBPoints'] = TF['RGBPoints']#.flatten().tolist()
    save_TF_json[0]['Points'] = TF['Points']#.flatten().tolist()
    
    with open(save_path, 'w') as f:
        json.dump(save_TF_json, f, indent=4, sort_keys=True)

def read_TF_json(TF_json_path):
    #* read the TF from a json file that can also be generated by Paraview
    TF = json.load(open(TF_json_path, 'r'))[0]
    OpacityPoints = TF['Points']#.reshape(-1, 4)
    RGBPoints = TF['RGBPoints']#.reshape(-1, 4)
    # ic(OpacityPoints, RGBPoints)
    return OpacityPoints, RGBPoints

def compose_TFs_fromList(TFs_json_list, opacity_factors=None, recolor_dict=None):
    #! This assume the TFs are all in the same range of [-1, 1]
    #! and the opacity shape is a rectangle
    #! we also assume TF_json_paths is sorted, TF1 is the first TF from left to right in colormap
    def remove_head_tail_points(opacityPoints, RGBPoints):
        opacityPoints = opacityPoints[2*4:-2*4]
        RGBPoints = RGBPoints[1*4:-1*4]
        return opacityPoints, RGBPoints
    res_TF = {"Points":[-1.,0.,0.5,0.],"RGBPoints":[-1.,0.,0.,0.]}
    for idx, TF_json in enumerate(TFs_json_list):
        opacityPoints, RGBPoints = TF_json['Points'], TF_json['RGBPoints']
        if opacity_factors is not None:
            opacityPoints[2*4+1] *= opacity_factors[idx] #* change the opacity of the middle point
            opacityPoints[3*4+1] *= opacity_factors[idx]
        opacityPoints, RGBPoints = remove_head_tail_points(opacityPoints, RGBPoints)
        if recolor_dict is not None:
            new_color = recolor_dict.get(idx, None)
            if new_color is not None:
                RGBPoints[1:4] = new_color
                RGBPoints[5:8] = new_color
        res_TF["Points"].extend(opacityPoints)
        res_TF["RGBPoints"].extend(RGBPoints)
    res_TF["Points"].extend([1.,0.,0.5,0.])
    res_TF["RGBPoints"].extend([1.,0.,0.,0.])
    return res_TF

def compose_TFs_fromPaths(TF_json_paths, opacity_factors=None):
    #! This assume the TFs are all in the same range of [-1, 1]
    #! and the opacity shape is a rectangle
    #! we also assume TF_json_paths is sorted, TF1 is the first TF from left to right in colormap
    def remove_head_tail_points(opacityPoints, RGBPoints):
        opacityPoints = opacityPoints[2*4:-2*4]
        RGBPoints = RGBPoints[1*4:-1*4]
        return opacityPoints, RGBPoints
    res_TF = {"Points":[-1.,0.,0.5,0.],"RGBPoints":[-1.,0.,0.,0.]}
    for idx, TF_json_path in enumerate(TF_json_paths):
        opacityPoints, RGBPoints = read_TF_json(TF_json_path)
        if opacity_factors is not None:
            opacityPoints[2*4+1] *= opacity_factors[idx] #* change the opacity of the middle point
            opacityPoints[3*4+1] *= opacity_factors[idx]
        opacityPoints, RGBPoints = remove_head_tail_points(opacityPoints, RGBPoints)
        res_TF["Points"].extend(opacityPoints)
        res_TF["RGBPoints"].extend(RGBPoints)
    res_TF["Points"].extend([1.,0.,0.5,0.])
    res_TF["RGBPoints"].extend([1.,0.,0.,0.])
    return res_TF

def exponential_decay(x, k=30): # k is the decay rate
    return np.clip(np.exp(-k * x)/2, 0.05, 0.5)
    # return np.exp(-k * x)/2

def get_color(x, total_length, cmap_name='viridis'):
    """
    Get the corresponding color by interpolation based on the input ratio x and total length.
    
    Parameters:
    x: The input ratio value (between 0 and total_length)
    total_length: The total length used to normalize x
    cmap_name: The name of the colormap to use (default is 'viridis')
    
    Returns:
    (r, g, b): Corresponding RGB color values
    """
    normalized_x = x / total_length # Normalize x to be between 0 and 1
    cmap = plt.get_cmap(cmap_name) # Get the colormap
    color = cmap(normalized_x)[:3] # Get the corresponding color based on the normalized x value
    return color

def getTFs(volPath,num_bins):
    v_arr =  np.fromfile(volPath, dtype='<f')
    frequency_hist, edges = np.histogram(v_arr, bins=num_bins) 
    opacity_arr = exponential_decay(frequency_hist/v_arr.shape[0])
    allTFs = [] # result TFs
    edges[-1] = 1.0 #* make sure the last bin is 1.0
    # ic(edges)
    # exit()
    for i in range(num_bins):
        # if opacity_arr[i] < 0.1: #* this remove the TFs with low opacity
        #     continue
        oneTF = {"RGBPoints":None, "Points":None}
        opacity_arr[i] = 0.25
        #* rectangle for one bin, random color
        Color = get_color(i,num_bins)
        oneTF["RGBPoints"] = np.array([[-1,0,0,0],[edges[i],Color[0],Color[1],Color[2]],[edges[i+1],Color[0],Color[1],Color[2]],[1,0,0,0]]).flatten().tolist()
        oneTF["Points"] = np.array([[-1,0,0.5,0],[edges[i],0,0.5,0],[edges[i],opacity_arr[i],0.5,0],[edges[i+1],opacity_arr[i],0.5,0],[edges[i+1],0,0.5,0],[1,0,0.5,0]]).flatten().tolist()
        # oneTF['Color'] = np.array(Color)[np.newaxis,:]
        allTFs.append(oneTF)
        # drawTFs(oneTF["RGBPoints"],oneTF["Points"],f"TF_{i}.png")
    return allTFs
    
    
def drawTFs(RGBPoints,Points,figPath):
    "draw TF from -1 to 1, RGBPoints and Points are the output of GetColorTransferFunction and GetOpacityTransferFunction"
    from matplotlib import pyplot as plt
    plt.figure(figsize=(10, 5))
    # rgb_points = RGBPoints.reshape(-1, 4)
    # opacity_points = Points.reshape(-1, 4)
    rgb_points = np.array(RGBPoints).reshape(-1, 4)
    opacity_points = np.array(Points).reshape(-1, 4)
    # TF style 1
    fig = plt.figure(figsize=(10, 5)) 
    axis_top = plt.subplot2grid((10, 1), (0, 0), rowspan=9) # ref: https://stackoverflow.com/questions/48744165/uneven-subplot-in-python
    axis_top.plot(opacity_points[:, 0], opacity_points[:, 1], 'k', label='Opacity')
    axis_top.set_xlim([opacity_points[0, 0], opacity_points[-1, 0]])
    axis_top.set_xticks([]) # remove x-axis label
    axis_top.set_ylim([0, 0.6]) #* max is 0.6
    ax_bottom = plt.subplot2grid((10, 1), (9, 0), rowspan=1)
    
    cmap_data = np.zeros((1, 1024, 3))
    x_coords = np.linspace(rgb_points[0, 0], rgb_points[-1, 0], 1024)
    cmap_data[0, :, 0] = np.interp(x_coords, rgb_points[:, 0], rgb_points[:, 1]) # Red Channel
    cmap_data[0, :, 1] = np.interp(x_coords, rgb_points[:, 0], rgb_points[:, 2]) # Green Channel
    cmap_data[0, :, 2] = np.interp(x_coords, rgb_points[:, 0], rgb_points[:, 3]) # Blue Channel

    ax_bottom.imshow(cmap_data, aspect='auto', extent=[rgb_points[0, 0], rgb_points[-1, 0], 0, 1]) # (left, right, bottom, top)
    ax_bottom.set_yticks([])
    ax_bottom.set_xlabel('')

    plt.tight_layout()
    plt.savefig(figPath)  # Save the plot as an image file
    plt.close()  # Close the figure to free memory